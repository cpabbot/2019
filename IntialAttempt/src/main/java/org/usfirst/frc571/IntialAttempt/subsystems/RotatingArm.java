// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc571.IntialAttempt.subsystems;


import org.usfirst.frc571.IntialAttempt.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.networktables.NetworkTableEntry;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.DigitalInput;
// import edu.wpi.first.wpilibj.Encoder;


/**
 *
 */
public class RotatingArm extends Subsystem {

    private ShuffleboardTab dataTab = Shuffleboard.getTab("Subsystems");
    private NetworkTableEntry armForwardLimitEntry, armReverseLimitEntry, encoderCountEntry;

    private DigitalInput forwardLimit;
    private DigitalInput reverseLimit;
    private WPI_TalonSRX armTalon;
    private static final double ROTATION = 1440;
    private static final int kTIMEOUT_MS = 100;
    private static final boolean kINVERTED = false; // invert motor
    private static final boolean kSENSOR_PHASE = true; // invert encoder
    private static final int kPID_LOOP_IDX = 0;
    // private static final int kSLOT_IDX = 0;
    private static final double kP = 10.0;
    private static final double kI = 0.0;
    private static final double kD = 1.0;
    private static final double kF = 0.0;
    public static final double RANGE = 2200.0;
    public static final double DEGREE = RANGE/100;

    public RotatingArm() {
        super("RotatingArm");

        forwardLimit = new DigitalInput(1);
        addChild("ForwardLimit", forwardLimit);
        reverseLimit = new DigitalInput(0);
        addChild("ReverseLimit", reverseLimit);
        
        armTalon = new WPI_TalonSRX(5);
        armTalon.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 30);

        /* Configure Arm Limits */
        armForwardLimitEntry = dataTab
            .add("RotatingArm/forwardLimit", forwardLimit.get())
            .getEntry();
        armReverseLimitEntry = dataTab
            .add("RotatingArm/reverseLimit", reverseLimit.get())
            .getEntry();

        encoderCountEntry = dataTab
            .add("RotatingArm/encoderCount", getEncoderCount())
            .getEntry();

        initializeTalon();
    }

    public void initializeTalon() {
        /* Ensure sensor is positive when output is positive */
        armTalon.setInverted(kINVERTED);
        armTalon.setSensorPhase(kSENSOR_PHASE);
        armTalon.setNeutralMode(NeutralMode.Brake);

        /* Config the peak and nominal outputs, 12V means full */
        // peak is max willing to drive motor, nominal is normal
        armTalon.configNominalOutputForward(0, kTIMEOUT_MS);
        armTalon.configNominalOutputReverse(0, kTIMEOUT_MS);
        armTalon.configPeakOutputForward(1, kTIMEOUT_MS);
        armTalon.configPeakOutputReverse(-1, kTIMEOUT_MS);

        /**
         * Config the allowable closed-loop error, Closed-Loop output will be neutral
         * within this range. See Table in Section 17.2.1 for native units per rotation.
         */
        armTalon.configAllowableClosedloopError(0, kPID_LOOP_IDX, kTIMEOUT_MS);

        /* Config Position Closed Loop gains in slot0, tsypically kF stays zero. */
        armTalon.config_kF(kPID_LOOP_IDX, kF, kTIMEOUT_MS);
        armTalon.config_kP(kPID_LOOP_IDX, kP, kTIMEOUT_MS);
        armTalon.config_kI(kPID_LOOP_IDX, kI, kTIMEOUT_MS);
        armTalon.config_kD(kPID_LOOP_IDX, kD, kTIMEOUT_MS);

        armTalon.setSelectedSensorPosition(0);
    }

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new RotateArm());
    }

    @Override
    public void periodic() {
        armForwardLimitEntry.setBoolean(forwardLimit.get());
        armReverseLimitEntry.setBoolean(reverseLimit.get());
        encoderCountEntry.setDouble(getEncoderCount());
    }

    public void RotateArm(double speed) {
        // System.out.println("rotating at speed of " + speed + ", control mode is " + armTalon.getControlMode());
        // arm moving down
        if((speed > 0) &&  armForwardLimitEntry.getBoolean(false)) {
            armTalon.set(ControlMode.PercentOutput, speed);
        }
        // arm moving up
        else if((speed < 0) && armReverseLimitEntry.getBoolean(false)) {
            armTalon.set(ControlMode.PercentOutput, speed);
        }
        else {
            armTalon.set(ControlMode.PercentOutput, 0.0);
        }
    }

    public void RotateTo(double targetCounts) {
        armTalon.set(ControlMode.Position, targetCounts);
    }

    public void rotate(double numRotations) {
        armTalon.set(ControlMode.Position, ROTATION*numRotations);
        // SmartDashboard.putNumber("position error", (double) armTalon.getClosedLoopError());
    }

    public void homeArm() {
        armTalon.set(ControlMode.PercentOutput, -0.5);
    }

    public void rotateToLowBall() {
        RotateTo(DEGREE * 55);
    }

    public void rotateToPanelPickup() {
        RotateTo(DEGREE * 65);
    }

    public void rotateToPanelRelease() {
        RotateTo(DEGREE * 70);
    }

    public void rotateToFloor() {
        RotateTo(RANGE);
    }

    public double getEncoderCount() {
        return armTalon.getSelectedSensorPosition();
    }

    public boolean getForwardLimit() {
        return armForwardLimitEntry.getBoolean(false);
    }

    public boolean getReverseLimit() {
        return armReverseLimitEntry.getBoolean(false);
    }

    public void zeroArmEncoder() {
        armTalon.setSelectedSensorPosition(0);
    }
}
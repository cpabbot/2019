// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc571.IntialAttempt.subsystems;


import org.usfirst.frc571.IntialAttempt.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.networktables.NetworkTableEntry;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class RotatingArm extends PIDSubsystem {

    private ShuffleboardTab dataTab = Shuffleboard.getTab("Subsystems");
    private NetworkTableEntry armForwardLimitEntry, armReverseLimitEntry;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private DigitalInput forwardLimit;
    private DigitalInput reverseLimit;
    private AnalogPotentiometer armPosition;
    private WPI_TalonSRX armTalon;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private Encoder quadratureEncoder1;
    private static final double ROTATION = 1440;
    private static final int kTIMEOUT_MS = 40;
    private static final boolean kSENSOR_PHASE = true;
    private static final boolean kMOTOR_INVERT = false;
    private static final int kPID_LOOP_IDX = 0;
    private static final int kSLOT_IDX = 0;
    private static final double kP = 0.15;
    private static final double kI = 0.0;
    private static final double kD = 1.0;
    private static final double kF = 0.0;

    public RotatingArm() {
        super("RotatingArm", 1.0, 0.0, 0.0);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        forwardLimit = new DigitalInput(1);
        addChild("ForwardLimit",forwardLimit);
        
        
        reverseLimit = new DigitalInput(0);
        addChild("ReverseLimit",reverseLimit);
        
        
        armTalon = new WPI_TalonSRX(5);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        setAbsoluteTolerance(0.2);
        getPIDController().setContinuous(false);
        getPIDController().setName("RotatingArm", "PIDSubsystem Controller");
        LiveWindow.add(getPIDController());
        
        quadratureEncoder1 = new Encoder(9, 10, false, EncodingType.k1X);
        addChild("Quadrature Encoder 1",quadratureEncoder1);
        quadratureEncoder1.setDistancePerPulse(1.0);
        quadratureEncoder1.setPIDSourceType(PIDSourceType.kRate);

        armForwardLimitEntry = dataTab
            .add("RotatingArm/forwardLimit", forwardLimit.get())
            .getEntry();

        armReverseLimitEntry = dataTab
            .add("RotatingArm/reverseLimit", reverseLimit.get())
            .getEntry();
    }

    public void initializeTalon() {
        /* Config the sensor used for Primary PID and sensor direction */
        armTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, kPID_LOOP_IDX,
                kTIMEOUT_MS);

        /* Ensure sensor is positive when output is positive */
        armTalon.setSensorPhase(kSENSOR_PHASE);

        /**
         * Set based on what direction you want forward/positive to be. This does not
         * affect sensor phase.
         */
        armTalon.setInverted(kMOTOR_INVERT);

        /* Config the peak and nominal outputs, 12V means full */
        armTalon.configNominalOutputForward(0, kTIMEOUT_MS);
        armTalon.configNominalOutputReverse(0, kTIMEOUT_MS);
        armTalon.configPeakOutputForward(1, kTIMEOUT_MS);
        armTalon.configPeakOutputReverse(-1, kTIMEOUT_MS);

        /**
         * Config the allowable closed-loop error, Closed-Loop output will be neutral
         * within this range. See Table in Section 17.2.1 for native units per rotation.
         */
        armTalon.configAllowableClosedloopError(0, kPID_LOOP_IDX, kTIMEOUT_MS);

        /* Config Position Closed Loop gains in slot0, tsypically kF stays zero. */
        armTalon.config_kF(kPID_LOOP_IDX, kF, kTIMEOUT_MS);
        armTalon.config_kP(kPID_LOOP_IDX, kP, kTIMEOUT_MS);
        armTalon.config_kI(kPID_LOOP_IDX, kI, kTIMEOUT_MS);
        armTalon.config_kD(kPID_LOOP_IDX, kD, kTIMEOUT_MS);

        /**
         * Grab the 360 degree position of the MagEncoder's absolute position, and
         * intitally set the relative sensor to match.
         */
        int absolutePosition = armTalon.getSensorCollection().getPulseWidthPosition();

        /* Mask out overflows, keep bottom 12 bits */
        absolutePosition &= 0xFFF;
        if (kSENSOR_PHASE) {
            absolutePosition *= -1;
        }
        if (kMOTOR_INVERT) {
            absolutePosition *= -1;
        }

        /* Set the quadrature (relative) sensor to match absolute */
        armTalon.setSelectedSensorPosition(absolutePosition, kPID_LOOP_IDX, kTIMEOUT_MS);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new RotateArm());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        armForwardLimitEntry.setBoolean(forwardLimit.get());
        armReverseLimitEntry.setBoolean(reverseLimit.get());
    }

    public void RotateArm(double speed) {
        // arm moving down
        if((speed > 0) &&  armForwardLimitEntry.getBoolean(false)) {
            armTalon.set(speed);
        }
        // arm moving up
        else if((speed < 0) && armReverseLimitEntry.getBoolean(false)) {
            armTalon.set(speed);
        }
        else {
            armTalon.set(0.0);
        }
    }

    public void RotateTo(double targetAngle) {
        
    }

    public void rotate(double numRotations) {
        armTalon.set(ControlMode.Position, ROTATION);
        // SmartDashboard.putNumber("position error", (double) armTalon.getClosedLoopError());
    }

    @Override
    protected double returnPIDInput() {
        return quadratureEncoder1.pidGet();
    }

    @Override
    protected void usePIDOutput(double output) {
        armTalon.pidWrite(output);
    }

    public double getEncoderCount() {
        return armTalon.getSelectedSensorPosition();
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

